[
	{
		"id": "java-pp-1",
		"question": "Consider the following block of code:<div class=\"code\"> <p>class NumberData {</p><p>&nbsp; private final int[] data;</p><p><br></p><p>&nbsp; public NumberData(final int numItems) {</p><p>&nbsp; &nbsp; data = new int[numItems];</p><p>&nbsp; }</p><p><br></p><p>&nbsp; public int[] getData() {&nbsp;</p><p>&nbsp; &nbsp; // IMPLEMENTATION HERE</p><p>&nbsp; }</p><p>}</p><p>public class MyClass {</p><p>&nbsp; public static void main(final String[] args) {</p><p>&nbsp; &nbsp; NumberData data = new NumberData(10);</p><p>&nbsp; &nbsp; // add numbers into data</p><p>&nbsp; &nbsp; int[] newData = data.getData();</p><p>&nbsp; &nbsp; newData[0] = 10;</p><p>&nbsp; }</p><p>}</p></div>What must you add into the getData() method to create a defensive copy of data?",
		"correct_answer": "return Arrays.copyOf(data, data.length);",
		"incorrect_answers": [
			"return new int[];",
			"return data;",
			"return Arrays.copyOf(data);"
		],
		"source": ""
	},
	{
		"id": "java-pp-2",
		"question": "Which type of operations transform into another stream?",
		"correct_answer": "Intermediate operations",
		"incorrect_answers": [
			"Terminal operations",
			"Collectors",
			"Pipelines"
		],
		"source": ""
	},
	{
		"id": "java-pp-3",
		"question": "You have a class named BookType with appropriate getters and setters. The following code contains a list of book types and then selects one of the book types: <div class=\"code\"><p>List&lt;BookType&gt; bookTypes = new ArrayList();</p><p>bookTypes.add(new BookType(&quot;History&quot;));</p><p>bookTypes.add(new BookType(&quot;Classic Literature&quot;));</p><p>bookTypes.add(new BookType(&quot;Biographies&quot;));</p><p>BookType bk = bookTypes.stream() &nbsp;.filter(book -&gt; &quot;History&quot;.equals(book.getName())).findAny();</p> </div>This code does not compile, what change can you make on line 5 for this to work?",
		"correct_answer": "Add an optional at the end, such as <span class=\"codeAnswer\">orElse(null)</span>",
		"incorrect_answers": [
			"Rename book to bk",
			"Change <span class=\"codeAnswer\">findAny()</span> to <span class=\"codeAnswer\">find()</span>",
			"Remove the <span class=\"codeAnswer\">.stream()</span>"
		],
		"source": ""
	},
	{
		"id": "java-pp-4",
		"question": "Which is a valid format for a constructor method reference?",
		"correct_answer": "<div class=\"codeAnswer\">ClassName::new</div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\">ClassName::super()</div>",
			"<div class=\"codeAnswer\">ClassName::this</div>",
			"<div class=\"codeAnswer\">ClassName::super()</div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-5",
		"question": "What does Java's lambda expression allow you to do?",
		"correct_answer": "Treat a function as an argument",
		"incorrect_answers": [
			"Achieve multiple inheritance",
			"Write single-statement anonymous methods",
			"Write single-parameter anonymous methods"
		],
		"source": ""
	},
	{
		"id": "java-pp-6",
		"question": "Which method of the java.util.function.Predicate interface allows you to chain two predicates?",
		"correct_answer": "Predicate<T> and(Predicate<? super T> other)",
		"incorrect_answers": [
			"Predicate<T> negate()",
			"Predicate<T> join(Predicate<? super T> other)",
			"Predicate<T> andThen(Predicate<? super T> other)"
		],
		"source": ""
	},
	{
		"id": "java-pp-7",
		"question": "How does Java pass reference type arguments to methods?",
		"correct_answer": "By value; a reference to the actual object is passed",
		"incorrect_answers": [
			"By reference; an actual copy of the object is passed with each method call",
			"By value; the actual object is passed",
			"By reference; the actual object is passed"
		],
		"source": ""
	},
	{
		"id": "java-pp-8",
		"question": "Consider the following lambda expression, where s is of type String: <div class=\"code\"> s -> s.isEmpty() </div> How would you rewrite this using a method reference?",
		"correct_answer": "<div class=\"codeAnswer\">String::isEmpty</div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\">s -> String::isEmpty()</div>",
			"<div class=\"codeAnswer\">String::isEmpty()</div>",
			"<div class=\"codeAnswer\">s -> String::isEmpty</div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-9",
		"question": "Given the following method definition:<div class=\"code\"><p>public static void someMethod(long arg, int... args) {</p><p>&nbsp; &nbsp; // assume implementation here</p><p>}</p></div> Which is a valid call of this method?",
		"correct_answer": "<div class=\"codeAnswer\">someMethod(1);</div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\">someMethod(new int[]{1,2});</div>",
			"<div class=\"codeAnswer\">someMethod(1, {2,3});</div>",
			"<div class=\"codeAnswer\">someMethod(1L, 2L, 3L);</div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-10",
		"question": "What is it called when you change the value of a variable inside a method and it retains that value after the method has completed?",
		"correct_answer": "Call by reference",
		"incorrect_answers": [
			"Side effect",
			"Immutability",
			"Call by value"
		],
		"source": ""
	},
	{
		"id": "java-pp-11",
		"question": "Why are Java streams described as lazy ?",
		"correct_answer": "Computation on the data source is only performed when the terminal operation starts",
		"incorrect_answers": [
			"When compared to an equivalent, pre-Java 8 implementation, using the streams application programming interface (API) will always result in a lower performance",
			"Using streams in your application will always turn on lazy-loading in any Java Persistence API (JPA) implementation that you use",
			"Computation on the data source is only performed when an intermediate operation starts"
		],
		"source": ""
	},
	{
		"id": "java-pp-12",
		"question": "What is true of terminal stream operations?",
		"correct_answer": "They always return a non-stream value such as a primitive or object type except for those whose return type is void. ",
		"incorrect_answers": [
			"They are lazily loaded.",
			"They may return either a stream or a non-stream value such as a primitive or object type.",
			"They always return a stream as a result."
		],
		"source": ""
	},
	{
		"id": "java-pp-13",
		"question": "You have the following declaration: <div class=\"code\">Predicate isEven = i -&gt; i % 2 == 0;</div> How can you use this declaration to create a predicate isOdd?",
		"correct_answer": "<div class=\"codeAnswer\">Predicate<Integer> isOdd = isEven.negate();</div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\">Predicate<Integer> isOdd = isEven.not();</div>",
			"<div class=\"codeAnswer\">Predicate<Integer> isOdd = Predicate.negate(isEven);</div>",
			"<div class=\"codeAnswer\">Predicate<Integer> isOdd = Predicate.not();</div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-14",
		"question": "What is encapsulation?",
		"correct_answer": "A means of determining the level of accessibility of your code",
		"incorrect_answers": [
			"When a class has the ability to take many different forms",
			"When a class acquires the characteristics of another class",
			"The process of showing only essential attributes and hiding unnecessary details from a user"
		],
		"source": ""
	},
	{
		"id": "java-pp-15",
		"question": "What is true about composition?",
		"correct_answer": "It allows for code reuse, even from a final class.",
		"incorrect_answers": [
			"It can expose a public method from the parent class.",
			"It provides its features at compile time.",
			"It can expose a protected method from the parent class."
		],
		"source": ""
	},
	{
		"id": "java-pp-16",
		"question": "Which method of the java.util.Comparator interface accepts an argument of type java.util.Function?",
		"correct_answer": "comparing",
		"incorrect_answers": [
			"compare",
			"comparingInt",
			"thenComparingInt"
		],
		"source": ""
	},
	{
		"id": "java-pp-17",
		"question": "Consider the following Java interface: <div class=\"code\"><p>interface StringValidator {</p><p>&nbsp; &nbsp; boolean test(String s);</p><p>&nbsp; &nbsp; default boolean initialTest(String s) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return !s.isEmpty();</p><p>&nbsp; &nbsp; }</p><p>}</p></div> Which is true of the StringValidator?",
		"correct_answer": "StringValidator is a functional interface.",
		"incorrect_answers": [
			"Adding an abstract method would make it a functional interface. ",
			"StringValidator has two abstract methods so it is not a valid functional interface.",
			"Annotating it with @FunctionalInterface and removing the default method would convert it to a functional interface. "
		],
		"source": ""
	},
	{
		"id": "java-pp-18",
		"question": "What will the following code snippet print out when executed?<div class=\"code\"><p>public class Parent {</p><p>&nbsp; &nbsp;public static String greet() {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return &quot;This is the parent speaking&quot;;</p><p>&nbsp; &nbsp; }</p><p>}</p><p>public class Child extends Parent {</p><p>&nbsp; &nbsp; public static String greet() {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return &quot;This is the child speaking&quot;;</p><p>&nbsp; &nbsp; }</p><p>}</p><p>public class Main {</p><p>&nbsp; &nbsp; public static void main(String[] args) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Parent p = new Parent();</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Parent c = new Child();</p><p>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(p.greet());</p><p>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(c.greet());</p><p>&nbsp; &nbsp; }</p><p>}</p></div>",
		"correct_answer": "<p>This is the parent speaking</p><p>This is the parent speaking</p>",
		"incorrect_answers": [
			"<p>This is the parent speaking</p><p>This is the child speaking</p>",
			"<p>This is the child speaking</p><p>This is the child speaking</p>",
			"<p>This is the child speaking</p><p>This is the parent speaking</p>"
		],
		"source": ""
	},
	{
		"id": "java-pp-19",
		"question": "What is true of static variables of a class?",
		"correct_answer": "They are statically bound at compile time.",
		"incorrect_answers": [
			"They are statically bound at run time.",
			"They are dynamically bound at compile time.",
			"They are dynamically bound at run time."
		],
		"source": ""
	},
	{
		"id": "java-pp-20",
		"question": "The following method hashes a char array:<div class=\"code\"><p>private final char[] arrayValues;</p><p>private hashValue = 0;</p><p><br></p><p>public int &nbsp;hashSelectedCode() {</p><p>&nbsp; &nbsp; char[] newArray = arrayValues;</p><p><br></p><p>&nbsp; &nbsp; for(int i = 0; i &lt; arrayValues.length; i++) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; hashValue += hash + arrayValues[i];</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // do any other possible calculations</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; return hashValue;</p><p>}</p></div> This is not thread-safe, however. What can you do to fix this?",
		"correct_answer": "In the hashSelectedCode method, create a copy of hashValue and populate your code in the loop.",
		"incorrect_answers": [
			"Declare hashValue as final.",
			"Enclose the code in the hashSelectedCode method in a lock statement to only allow one thread in at a time.",
			"In the hashSelectedCode method, iterate through newArray instead of arrayValues in the for loop."
		],
		"source": ""
	},
	{
		"id": "java-pp-21",
		"question": "Why is immutability key to the functional programming paradigm?",
		"correct_answer": "It minimizes conflicts among objects.",
		"incorrect_answers": [
			"It encapsulates moving parts.",
			"It provides a centralized way for state to leak out.",
			"It is faster for developers to write functional code if the objects are immutable."
		],
		"source": ""
	},
	{
		"id": "java-pp-22",
		"question": "Which type of operations transform into another stream?",
		"correct_answer": "Intermediate operations",
		"incorrect_answers": [
			"Terminal operations",
			"Pipelines",
			"Collectors"
		],
		"source": ""
	},
	{
		"id": "java-pp-23",
		"question": "What does Java use to achieve runtime polymorphism?",
		"correct_answer": "Overriding",
		"incorrect_answers": [
			"Abstraction",
			"Overloading",
			"Encapsulation"
		],
		"source": ""
	},
	{
		"id": "java-pp-24",
		"question": "Using a function of type java.util.function.BiFunction, which option correctly defines a partial function that takes arguments of type String?",
		"correct_answer": "<div class=\"codeAnswer\"><p>Function partial(BiFunction f, String y) {</p><p>&nbsp;return (x) -&gt; f.apply(x, y);&nbsp;</p><p>}</p></div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\"><p>Integer partial(BiFunction f, String y) {&nbsp;</p><p>return f.apply(y);&nbsp;</p><p>}</p></div>",
			"<div class=\"codeAnswer\"><p>Function partial(BiFunction f, String x, String y) {&nbsp;</p><p>return (x) -&gt; f.apply(x, y);&nbsp;</p><p>} </p></div>",
			"<div class=\"codeAnswer\"><p>BiFunction partial(Function f, String y) {&nbsp;</p><p>return (x) -&gt; f.apply(x, y);&nbsp;</p><p>} &nbsp;</p></div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-25",
		"question": "Given the following code:<div class=\"code\"><p>class Book {</p><p>&nbsp; &nbsp; private String title;</p><p>&nbsp; &nbsp; private String author;</p><p><br></p><p>&nbsp; &nbsp; public Book(String title, String author) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; this.title = title;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; this.author = author;</p><p>&nbsp; &nbsp; }</p><p><br></p><p>&nbsp; &nbsp; interface IBookBuilder {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IBookBuilder2 withTitle(String title);</p><p>&nbsp; &nbsp; }</p><p><br></p><p>&nbsp; &nbsp; interface IBookBuilder2 {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Book withAuthor(String author);</p><p>&nbsp; &nbsp; }</p><p><br></p><p>&nbsp; &nbsp; public static IBookBuilder build() {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return f1 -&gt; f2 -&gt; new Book(f1, f2);</p><p>&nbsp; &nbsp; }</p><p>}</p></div>Which option builds a Book instance?",
		"correct_answer": "<div class=\"codeAnswer\"><p>Book b = Book</p><p>&nbsp;.build()</p><p>&nbsp;.withTitle(&quot;title&quot;)</p><p>&nbsp;.withAuthor(&quot;author&quot;);</p></div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\"><p>Book b = Book</p><p>&nbsp;.withTitle(() -&gt; &quot;title&quot;)</p><p>&nbsp;.withAuthor(()-&gt;&quot;author&quot;)</p><p>&nbsp;.build();</p></div>",
			"<div class=\"codeAnswer\"><p>Book b = Book</p><p>&nbsp;.build()</p><p>&nbsp;.andThen(() -&gt; &quot;title&quot;)</p><p>&nbsp;.andThen(() -&gt; &quot;author&quot;);</p></div>",
			"<div class=\"codeAnswer\"><p>Book b = Book</p><p>&nbsp;.withTitle(&quot;title&quot;)</p><p>&nbsp;.withAuthor(&quot;author&quot;)</p><p>&nbsp;.build();</p></div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-26",
		"question": "Which code block is equivalent to the following reduce method of the java.util.stream.Stream interface?<div class=\"code\">T reduce(T val, BinaryOperator<T> operator)</div>",
		"correct_answer": "<div class=\"codeAnswer\"><p>T result = val;</p><p>for (T element : stream)</p><p>&nbsp; &nbsp; result =operator.apply(result, element);</p><p>return result;</p></div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\"><p>T result = null;</p><p>for (T element : stream)</p><p>&nbsp; &nbsp; result = operator.apply(val, element);</p><p>return result;</p></div>",
			"<div class=\"codeAnswer\"><p>T result = null;</p><p>for (T element : stream)</p><p>&nbsp; &nbsp; result = operator.apply(result, element);</p><p>return result != null ? result : val;</p></div>",
			"<div class=\"codeAnswer\"><p>T result = val;</p><p>for (T element : stream)</p><p>&nbsp; &nbsp; result =operator.apply(element);</p><p>return result;</p></div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-27",
		"question": "Which method of the java.util.function.BiFunction interface allows you to compose functions?",
		"correct_answer": "<div class=\"codeAnswer\">BiFunction<T,U,V> andThen(Function&lt;? super R,? extends V&gt; f)</div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\">BiFunction<T,U,V> compose(BiFunction&lt;? super R,? extends V&gt; f)</div>",
			"<div class=\"codeAnswer\">BiFunction<T,U,V> andThen(BiFunction&lt;? super R,? extends V&gt; f)</div>",
			"<div class=\"codeAnswer\">BiFunction<T,U,V> and(Function&lt;? super R,? extends V&gt; f)</div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-28",
		"question": "The Student class is defined and its constructor sets the name field. What will happen when you execute the following code snippet?<div class=\"code\"><p>public static void main(String[] args) {</p><p>&nbsp; &nbsp; Student aStudent = new Student(&quot;Student1&quot;);</p><p>&nbsp; &nbsp; clearStudentName(aStudent);</p><p>&nbsp; &nbsp; System.out.println(aStudent.name);</p><p>}</p><p>public static void clearStudentName(Student student) {</p><p>&nbsp; &nbsp; student = new Student(&quot;NO_NAME&quot;);</p><p>}</p></div>",
		"correct_answer": "Student1 will be printed out",
		"incorrect_answers": [
			"NO_NAME will be printed out",
			"A compile-time exception will be thrown because you cannot use reference type arguments in static contexts",
			"A run-time exception will be thrown because you cannot use reference type arguments in static contexts"
		],
		"source": ""
	},
	{
		"id": "java-pp-29",
		"question": "You are working on an application that is making extensive use of polymorphism. A number of your classes use the method overriding feature of Java, together with method hiding. An incorrect version of a static method is being called. Where would you start looking for the problem?",
		"correct_answer": "Look at how that method is being called in your hierarchy (method usage).",
		"incorrect_answers": [
			"Look for wrong usages of extends rather than implements.",
			"Look for wrong usages of implements rather than extends.",
			"Look for misused @Override annotations."
		],
		"source": ""
	},
	{
		"id": "java-pp-30",
		"question": "Consider the following code: <div class=\"code\"><p>class Person {</p><p>&nbsp; &nbsp; private int age;</p><p>&nbsp; &nbsp; // getters and setters</p><p>}</p><p>public class MyClass {</p><p>/**L1*/ &nbsp; &nbsp;public static void multiplyNumbers(Person person) &nbsp;{</p><p>/**L2*/ &nbsp; &nbsp; &nbsp; person.setAge(person.getAge() * 2);</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; public static void main(String[] args) {</p><p>/**L3*/ &nbsp; &nbsp; &nbsp; &nbsp;Person person = new Person();</p><p>/**L4*/ &nbsp; &nbsp; &nbsp; &nbsp;person.setAge(30);</p><p>/**L5*/ &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(&quot;Person age: &quot; + person.getAge());</p><p>/**L6*/ &nbsp; &nbsp; &nbsp; &nbsp;multiplyNumbers(person);</p><p>/**L7*/ &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(&quot;Person age: &quot; + person.getAge());</p><p>&nbsp; &nbsp; }</p><p>}</p></div> What change can you make so this code no longer passes the object reference as a value so it becomes a concrete example of pass-by-value?",
		"correct_answer": "Change the parameter in line 1 to be a primitive type and change lines 2 and 6 accordingly.",
		"incorrect_answers": [
			"Change line 4 to: <span class=\"codeAnswer\">int age = person.setAge(30);</span>",
			"Add a new line of code after line 4 with a variable set to the person's age and update lines 5 and 7 to print out that variable value instead.",
			"Remove the static keyword in line 1."
		],
		"source": ""
	},
	{
		"id": "java-pp-31",
		"question": "The following class declaration attempts to achieve immutability: <div class=\"code\"><p>final public class Immutable {</p><p></p><p>    private final PotentiallyImmutable collaborator;</p><p></p><p>    public Immutable(PotentiallyImmutable collaborator) {</p><p>        this.collaborator = collaborator;</p><p>    }</p><p>}</p></div> PotentiallyImmutable is declared and you can't be sure whether it's immutable or not. If you still need the collaborator type, which change would you make to the Immutable class to ensure that it is indeed fully immutable?",
		"correct_answer": "Create a copy of the collaborator constructor argument and store this reference instead.",
		"incorrect_answers": [
			"Mark the collaborator instance variable as volatile.",
			"Annotate the constructor with @ThreadSafe.",
			"Make the constructor private."
		],
		"source": ""
	},
	{
		"id": "java-pp-32",
		"question": "You designed the following class to be immutable but it is not. Why not?<div class=\"code\"><p>import java.util.Date;</p><p>public final class SomewhatImmutable {</p><p>&nbsp; &nbsp;private final String id;</p><p>&nbsp; &nbsp;private final Date dateCreated;</p><p></p><p>&nbsp; &nbsp;public SomewhatImmutable(String id, Date dateCreated) {</p><p>&nbsp; &nbsp;&nbsp; &nbsp;this.id = id;</p><p>&nbsp; &nbsp;&nbsp; &nbsp;this.dateCreated = dateCreated;</p><p>&nbsp; &nbsp;}</p><p></p><p>&nbsp; &nbsp;public String getId() {</p><p>&nbsp; &nbsp;&nbsp; &nbsp;return id;</p><p>&nbsp; &nbsp;}</p><p></p><p>&nbsp; &nbsp;public Date getDateCreated() {</p><p>&nbsp; &nbsp;&nbsp; &nbsp;return dateCreated;</p><p>&nbsp; &nbsp;}</p><p>}</p></div>",
		"correct_answer": "The Date class is not immutable. You should have used defensive copying in the constructor and the getter to protect the object from changes the original caller made to the Date object and to prevent leaking the mutable Date field with the getter.",
		"incorrect_answers": [
			"The class is using a constructor rather than setter methods, which makes it impossible to enforce any immutability constraints when the arguments are passed in.",
			"The Date class is mutable and objects having a state that contains mutable objects cannot be made immutable without replacing the mutable types of the state with immutable types.",
			"The String class is not immutable. You should have used defensive copying in the constructor and the getter to protect the object from changes the original caller made to the String object and to prevent leaking the mutable String field with the getter."
		],
		"source": ""
	},
	{
		"id": "java-pp-33",
		"question": "Which combination of functional interfaces would you use to implement a partial function application and to test an object based on a condition respectively?",
		"correct_answer": "java.util.function.BiFunction and java.util.function.Predicate ",
		"incorrect_answers": [
			"java.util.function.Function and java.util.function.Consumer ",
			"java.util.function.UnaryOperator and java.util.function.BiPredicate ",
			"java.util.function.BooleanSupplier and java.util.function.Supplier"
		],
		"source": ""
	},
	{
		"id": "java-pp-34",
		"question": "What will be the output of the following program? <div class=\"code\"><p>class MyClass {</p><p>&nbsp; public double addNumbers(double num1, double num2) {</p><p>&nbsp; &nbsp; return num1 + num2 + 1;</p><p>&nbsp; }</p><p></p><p>&nbsp; public double addNumbers(double num1) {</p><p>&nbsp; &nbsp; return num1 + 2;</p><p>&nbsp; }</p><p></p><p>&nbsp; public double addNumbers(int num1) {</p><p>&nbsp; &nbsp; return num1 + 3;</p><p>&nbsp; }</p><p></p><p>&nbsp; public double addNumbers(float num1) {</p><p>&nbsp; &nbsp; return num1 + 4;</p><p>&nbsp; }</p><p></p><p>&nbsp; public static void main(String[] args) {</p><p>&nbsp; &nbsp; MyClass c = new MyClass();</p><p>&nbsp; &nbsp; System.out.println(c.addNumbers(3.0));</p><p>&nbsp; }</p><p>}</p></div>",
		"correct_answer": "5.0",
		"incorrect_answers": [
			"7.0",
			"4.0",
			"6.0"
		],
		"source": ""
	},
	{
		"id": "java-pp-35",
		"question": "What type of a relationship does composition use?",
		"correct_answer": "PART-OF",
		"incorrect_answers": [
			"HAS-A",
			"IS-A",
			"JOIN-A"
		],
		"source": ""
	},
	{
		"id": "java-pp-36",
		"question": "Consider the following block of code: <div class=\"code\"><p>public final class Person {</p><p>&nbsp; private Date dateOfBirth;</p><p>&nbsp; private String name;</p><p>&nbsp; </p><p>&nbsp; public Person(Date dob, String name) {</p><p>&nbsp; &nbsp; this.name = name;</p><p>&nbsp; &nbsp; this.dateOfBirth = dob;</p><p>&nbsp; }</p><p>}</p></div> How would you change this class to return a defensive copy of the dateOfBirth variable?",
		"correct_answer": "Create a new Date instance in the class constructor<div class=\"codeAnswer\">this.dateOfBirth = new Date((dateOfBirth.getTime());</div>",
		"incorrect_answers": [
			"Declare the dateOfBirth variable as public<div class=\"codeAnswer\">public Date dateOfBirth;</div>",
			"Add a getter method which returns the dateOfBirth variable<div class=\"codeAnswer\"><p>public void getDateOfBirth() {</p><p>&nbsp; return dateOfBirth;</p><p>}</p></div>",
			"Declare the dateOfBirth variable as final<div class=\"codeAnswer\">private final Date dateOfBirth;</div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-37",
		"question": "If immutable objects cannot change state after creation, what is the industry best practice for updating them?",
		"correct_answer": "An immutable class requires a new object for each distinct value and therefore you can only perform an update by creating a brand new object.",
		"incorrect_answers": [
			"Use the State design pattern to make this change.",
			"Use reflection to update the immutable state.",
			"Perform the update with a separate thread and do not use the thread that created the object."
		],
		"source": ""
	},
	{
		"id": "java-pp-38",
		"question": "In the following Stream pipeline the SomeObject class exists and it has a visible id instance variable: <div class=\"code\"><p>final List<SomeObject> result = someObjects</p><p>&nbsp; .stream()</p><p>&nbsp; .filter(element -> element.id.startsWith(\"404\"))</p><p>&nbsp; .map(element -> element.id)</p><p>&nbsp; .collect(Collectors.toList());</p></div>What is wrong with it?",
		"correct_answer": "The map intermediate operation maps the data from SomeObject type to a String type, which should be reflected in the type of the result variable.",
		"incorrect_answers": [
			"There are two intermediate operations but a maximum of one is permitted.",
			"When more than one intermediate operation is used, the Stream API states that a parallel stream must be used and therefore stream() must be replaced with parallelStream().",
			"A terminal operation must always follow an intermediate operation and, therefore, the collect call should be placed immediately after filter and immediately before map."
		],
		"source": ""
	},
	{
		"id": "java-pp-40",
		"question": "In the context of Java, why is the design principle \"Favor composition over inheritance\" generally accepted?",
		"correct_answer": "Overusing inheritance can lead to increased maintenance effort and increased resistance to change",
		"incorrect_answers": [
			"Composition is more portable than inheritance and goes hand in hand with Java's \"write once, run anywhere\" principle",
			"Inheritance has become less important as a design principle as composition has gained popularity",
			"Composition is always faster than inheritance"
		],
		"source": ""
	},
	{
		"id": "java-pp-41",
		"question": "Consider the following if-else statement: <div class=\"code\"><p>class TestClass {</p><p>&nbsp; public static void main(String[] args) {</p><p>&nbsp; &nbsp; int i = 0;</p><p>&nbsp; &nbsp; if ((Boolean) i)</p><p>&nbsp; &nbsp; &nbsp; System.out.print(\"Good morning World\");</p><p>&nbsp; &nbsp; else</p><p>&nbsp; &nbsp; &nbsp; System.out.print(\"Good night World\");</p><p>&nbsp; &nbsp; &nbsp; System.out.print(\"Hello World\");&nbsp;  </p><p>&nbsp; }</p><p>}</p></div>Why does this block of code have a syntax error?",
		"correct_answer": "Because you cannot directly cast an int to a Boolean",
		"incorrect_answers": [
			"Because there are two statements under else and there must be brackets surrounding them",
			"Because i is not being compared to anything in the if statement",
			"Because you cannot cast a primitive int to a Boolean wrapper; you must use boolean as a primitive"
		],
		"source": ""
	},
	{
		"id": "java-pp-42",
		"question": "You are writing your first Java stream. You chose your data source, added a few filters, and are ready to finish the stream pipeline. What type of operation do you need now?",
		"correct_answer": "Terminal",
		"incorrect_answers": [
			"Finisher",
			"Intermediate",
			"Finalizer"
		],
		"source": ""
	},
	{
		"id": "java-pp-43",
		"question": "What is the main difference between intermediate and terminal Java stream operations?",
		"correct_answer": "Intermediate operations transform a stream into another stream, whereas terminal operations produce a result or a side effect.",
		"incorrect_answers": [
			"Terminal operations can be carried out in parallel, whereas intermediate operations can't.",
			"Intermediate operations provide various ways for the clients to start the processing, such as on delay or on multiple threads, whereas terminal operations provide multiple stopping mechanisms, such as on timeout or on failure.",
			"When initiated, intermediate operations immediately carry out the actual computation, whereas terminal operations don't."
		],
		"source": ""
	},
	{
		"id": "java-pp-44",
		"question": "What will the following code snippet print out when executed? <div class=\"code\"> <p>public static void main(String[] args) {</p><p>&nbsp; int score = 70;</p><p>&nbsp; switch (score) {</p><p>&nbsp; &nbsp; case 70:</p><p>&nbsp; &nbsp; &nbsp; System.out.println(\"Great score!\");</p><p>&nbsp; &nbsp; case 50:</p><p>&nbsp; &nbsp; &nbsp; System.out.println(\"Pass score\");</p><p>&nbsp; &nbsp; default:</p><p>&nbsp; &nbsp; &nbsp; System.out.println(\"Unknown score\");</p><p>&nbsp; }</p><p>}</p></div>",
		"correct_answer": "<p>Great score!</p><p>Pass score</p><p>Unknown score</p>",
		"incorrect_answers": [
			"Great score!",
			"<p>Great score!</p><p>Pass score</p>",
			"<p>Great score!</p><p>Unknown score</p>"
		],
		"source": ""
	},
	{
		"id": "java-pp-45",
		"question": "If you override a method that returns a type T, what return type can this method have?",
		"correct_answer": "T or a subtype of T",
		"incorrect_answers": [
			"A subtype of T only",
			"A supertype of T only",
			"T only"
		],
		"source": ""
	},
	{
		"id": "java-pp-46",
		"question": "Consider the following Java functional interface: <div class=\"code\"><p>interface StringValidator {</p><p>&nbsp; boolean test(String s);</p><p>}</p></div>While implementing StringValidator interface in a class, what lambda expression could represent the test method?",
		"correct_answer": "<div class=\"codeAnswer\">s -> !s.isEmpty()</div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\">s -> return true</div>",
			"<div class=\"codeAnswer\">() -> return true</div>",
			"<div class=\"codeAnswer\">() -> true</div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-47",
		"question": "Which block of code represents a correct implementation of a defensive copy of a variable called dateOfBirth?",
		"correct_answer": "<div class=\"codeAnswer\"><p>public Date getDateOfBirth() {</p><p>&nbsp; return new Date(dateOfBirth.getTime());</p><p>}</p></div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\"><p>public Date getDateOfBirth() {</p><p>&nbsp; return dateOfBirth;</p><p>}</p></div>",
			"<div class=\"codeAnswer\"><p>public Object getDateOfBirth() {</p><p>&nbsp; return dateOfBirth;</p><p>}</p></div>",
			"<div class=\"codeAnswer\"><p>public Date getDateOfBirth() {</p><p>&nbsp; return new Date();</p><p>}</p></div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-48",
		"question": "Given the following Stateful class, which doesn't define any setter methods that could be used to mutate its state: <div class=\"code\"> <p>import java.util.Set;</p><p>public class Stateful {</p><p>&nbsp; private Set<String> content;</p><p>&nbsp; public Stateful(Set<String> content) {</p><p>&nbsp; &nbsp; this.content = content;</p><p>&nbsp; }</p><p>&nbsp; public Set<String> getContent() {</p><p>&nbsp; &nbsp; return content;</p><p>&nbsp; }</p><p>}</p> </div> You have access to an object of type Stateful, referenced by a variable stateful. Which is a modification of the state of the object referenced by stateful?",
		"correct_answer": "<div class=\"codeAnswer\">stateful.getContent() = new HashSet<>();</div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\">stateful.getContent().add(\"yet another state\");</div>",
			"<div class=\"codeAnswer\">stateful.content.add(\"yet another state\");</div>",
			"<div class=\"codeAnswer\">stateful.content = new HashSet<>();</div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-49",
		"question": "What is one concrete benefit of functional code that only uses immutable types?",
		"correct_answer": "It reduces side effects such as updating a local state.",
		"incorrect_answers": [
			"All your objects are serializable by default.",
			"You can replace re-entrant locks with implicit monitor locks without causing any issues.",
			"You don't have to use design patterns anymore."
		],
		"source": ""
	},
	{
		"id": "java-pp-50",
		"question": "Which java.util.Collections method will return a Collection object which could throw an UnsupportedOperationException if you try to change that Collection object in its immutable state? ",
		"correct_answer": "unmodifiableCollection",
		"incorrect_answers": [
			"binarySearch",
			"synchronizedCollection",
			"max"
		],
		"source": ""
	},
	{
		"id": "java-pp-51",
		"question": "Given the following code: <div class=\"code\"><p>public class Test {</p><p> </p><p>&nbsp;&nbsp;static Function<String, String> apply(BiFunction<String, String, String> f, String a) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return b -> f.apply(a, b);</p><p>&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;static Function<String, String> apply2(String s) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return (a) -> a + s;</p><p>&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;public static void main(String args[]) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Function<String, String> trim = String::trim;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Function<String, String> partial = apply((a, b) -> a+b, \"x \");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Predicate<String> filter = s -> s.length() > 3;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;List<String> words = List.of(\"one \", \"two \", \"three \");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;words.stream()</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map((String s1) -> filter.test(s1)? partial : trim)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(f -> f.andThen(s2 -> s2 + \"X \"))</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(/* INSERT OPTION HERE */)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::print);</p><p>&nbsp;&nbsp;}</p>}</div><p>Which option can you insert in the last map function on line 15 so the program compiles correctly?</p>",
		"correct_answer": "f.apply(\"-\")",
		"incorrect_answers": [
			"String::toUpperCase",
			"Test::apply2",
			"f -> f.compose(s1 + s2)"
		],
		"source": ""
	},
	{
		"id": "java-pp-52",
		"question": "<p>Which option composes the following two predicates to represent a short-circuiting logical OR?</p><div class=\"code\"><p>Predicate<Integer> p1 = (i) -> i > 10;</p><p>Predicate<Integer> p2 = (i) -> i < 5;</p></div>",
		"correct_answer": "p1.or(p2)",
		"incorrect_answers": [
			"p1.merge(p2)",
			"p1.xor(p2)",
			"p1.test(p2)"
		],
		"source": ""
	},
	{
		"id": "java-pp-54",
		"question": "<p>Consider the following code snippet:</p><div class=\"code\"><p>public class Main {</p><p>&nbsp;&nbsp;public static void main(String[] args) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;String myFirstReferenceVariable;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(myFirstReferenceVariable);</p><p>&nbsp;&nbsp;}</p><p>}</p></div><p>What happens when you try to compile and execute it?</p>",
		"correct_answer": "A compile-time exception will be thrown because the local variable hasn't been initialized",
		"incorrect_answers": [
			"It will print out null",
			"It will print out a blank string",
			"A run-time exception will be thrown because the local variable hasn't been initialized"
		],
		"source": ""
	},
	{
		"id": "java-pp-55",
		"question": "<p>You designed the following class to be immutable but it is not. Why not?</p><div class=\"code\"><p>import java.util.Date;</p><p>public final class SomewhatImmutable {</p><p>&nbsp;&nbsp;private final String id;</p><p>&nbsp;&nbsp;private final Date dateCreated;</p><p>&nbsp;&nbsp;public SomewhatImmutable(String id, Date dateCreated) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;this.dateCreated = dateCreated;</p><p>&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;public String getId() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return id;</p><p>&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;public Date getDateCreated() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return dateCreated;</p><p>&nbsp;&nbsp;}</p><p>}</p><p></p><p></p></div>",
		"correct_answer": "The Date class is not immutable. You should have used defensive copying in the constructor and the getter to protect the object from changes the original caller made to the Date object and to prevent leaking the mutable Date field with the getter.",
		"incorrect_answers": [
			"The String class is not immutable. You should have used defensive copying in the constructor and the getter to protect the object from changes the original caller made to the String object and to prevent leaking the mutable String field with the getter.",
			"The Date class is mutable and objects having a state that contains mutable objects cannot be made immutable without replacing the mutable types of the state with immutable types.",
			"The class is using a constructor rather than setter methods, which makes it impossible to enforce any immutability constraints when the arguments are passed in."
		],
		"source": ""
	},
	{
		"id": "java-pp-56",
		"question": "If you correctly implement immutability, where is the only place you should be able change an object's state?",
		"correct_answer": "The class constructor",
		"incorrect_answers": [
			"The get method",
			"In a subclass",
			"The set method"
		],
		"source": ""
	},
	{
		"id": "java-pp-57",
		"question": "What does it mean that Java passes primitive method arguments by value?",
		"correct_answer": "Changes to the values of the parameters exist only within the scope of the method.",
		"incorrect_answers": [
			"If called with an insufficient number of arguments, methods will assume default values for the missing ones, based on their types.",
			"Methods will not accept primitive parameters that have not been explicitly initialized.",
			"Methods will infer the type of the parameters based on the arguments, therefore you can omit the type of parameters when declaring the method."
		],
		"source": ""
	},
	{
		"id": "java-pp-58",
		"question": "Which block of code will produce a value of 15 when its value is printed at the end of a while loop?",
		"correct_answer": "<div class=\"codeAnswer\"><p>int m = 5;</p><p>while (m &lt; 15) {</p><p>&nbsp;&nbsp;m++;</p><p>}</p><p>System.out.println(\"m: \" + m);</p></div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\"><p>int m = 8;</p><p>while (m &lt;= 16) {</p><p>&nbsp;&nbsp;m++;</p><p>}</p><p>System.out.println(\"m: \" + m);</p></div>",
			"<div class=\"codeAnswer\"><p>int m = 1;</p><p>while (m &lt;= 15) {</p><p>&nbsp;&nbsp;m++;</p><p>}</p><p>System.out.println(\"m: \" + m);</p></div>",
			"<div class=\"codeAnswer\"><p>int m = 0;</p><p>while (m &lt; 16) {</p><p>&nbsp;&nbsp;m++;</p><p>}</p><p>System.out.println(\"m: \" + m);</p></div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-59",
		"question": "What is the main role of a lambda expression?",
		"correct_answer": "To implement the method of a functional interface",
		"incorrect_answers": [
			"To override a single method of any named class",
			"To implement a single method of any interface",
			"To override a single method of any anonymous class"
		],
		"source": ""
	},
	{
		"id": "java-pp-60",
		"question": "Why is immutability so important in a multi-threaded Java application?",
		"correct_answer": "If an object cannot change its state after construction, it is impossible for thread interference to leave that object in a corrupt state, or for a thread to use the object while it is in an inconsistent state.",
		"incorrect_answers": [
			"The Java functional application programming interface (API) cannot work with thread-unsafe objects and using this API is mandatory in any multi-threaded application.",
			"Because of architectural reasons, it is the only way to achieve thread safety that can be applied to the Java platform.",
			"A multi-threaded application can work correctly without thread-safe objects, but it will result in significantly reduced performance."
		],
		"source": ""
	},
	{
		"id": "java-pp-61",
		"question": "What does it mean that Java passes reference method arguments by value?",
		"correct_answer": "When the method exits, the passed-in argument reference still points to the same object as before the method call. The values of that object's fields can be changed in the method, however.",
		"incorrect_answers": [
			"When the method exits, the passed-in argument reference still points to the same object as before the method call. The values of that object's fields cannot be changed in the method.",
			"Methods do not accept null values for reference type arguments unless they are annotated with @Nullable.",
			"Methods will infer the type of the parameters based on the arguments, therefore the type of parameters can be omitted when declaring the method."
		],
		"source": ""
	},
	{
		"id": "java-pp-62",
		"question": "How many terminal operations can a stream pipeline have?",
		"correct_answer": "0 or 1",
		"incorrect_answers": [
			"3",
			"2",
			"1-5"
		],
		"source": ""
	},
	{
		"id": "java-pp-63",
		"question": "At object creation, what would you use if you wanted to return a duplicated version of your object instead of the original one you created?",
		"correct_answer": "Defensive copy",
		"incorrect_answers": [
			"Mutator method",
			"Overridden variable",
			"Accessor method"
		],
		"source": ""
	},
	{
		"id": "java-pp-64",
		"question": "What is it called when you change the value of a variable inside of a method, but the variable retains that value only while in that method?",
		"correct_answer": "Call by value",
		"incorrect_answers": [
			"Immutability",
			"Side effect",
			"Call by reference"
		],
		"source": ""
	},
	{
		"id": "java-pp-65",
		"question": "<p>Given the following Stateful class, which doesn't define any setter methods that could be used to mutate its state:</p><div class=\"code\"><p>import java.util.Set;</p><p>public class Stateful {</p><p>&nbsp;&nbsp;private Set<String> content;</p><p>&nbsp;&nbsp;public Stateful(Set&lt;String&gt; content) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;</p><p>&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;public Set<String> getContent() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return content;</p><p>&nbsp;&nbsp;}</p><p>}</p></div><p>You have access to an object of type Stateful, referenced by a variable stateful. Which is a modification of the state of the object referenced by stateful?</p>",
		"correct_answer": "<div class=\"codeAnswer\">stateful.getContent().add(\"yet another state\");</div>",
		"incorrect_answers": [
			"<div class=\"codeAnswer\">stateful.content.add(\"yet another state\");</div>",
			"<div class=\"codeAnswer\">stateful.getContent() = new HashSet&lt;String&gt;();</div>",
			"<div class=\"codeAnswer\">stateful.content = new HashSet&lt;String&gt;();</div>"
		],
		"source": ""
	},
	{
		"id": "java-pp-66",
		"question": "<p>Given the following class:</p><div class=\"code\"><p>class User { </p><p>&nbsp;&nbsp;private String name; </p><p>&nbsp;&nbsp;private int age;</p><p>&nbsp;&nbsp;// Constructor that takes the two above properties</p><p>&nbsp;&nbsp;// Getter and setters for name and age </p><p>}</p></div><p>And the following array:</p><div class=\"code\"><p>User[] users = new User[] {</p><p>&nbsp;&nbsp;new User(\"User1\", 20),</p><p>&nbsp;&nbsp;new User(\"User2\", 18),</p><p>&nbsp;&nbsp;new User(\"User1\", 30) </p><p>};</p></div><p>Which comparator will sort the array by name and then sort by age ascending on duplicated names?</p>",
		"correct_answer": "Comparator.comparing(User::getName).thenComparing(User::getAge)",
		"incorrect_answers": [
			"Comparator.comparing(User::getAge).thenComparing(User::getName)",
			"Comparator.comparing(User::getName, User::getAge)",
			"Comparator.compare(User::getName, User::getAge)"
		],
		"source": ""
	},
	{
		"id": "java-pp-67",
		"question": "What is a good way to ensure that changes to shared objects do not negatively affect the other objects using them?",
		"correct_answer": "Sharing copies of the objects in scope, rather than the actual objects",
		"incorrect_answers": [
			"Redesigning and using a single class instead of multiple classes",
			"Making all the variables of all the classes involved final",
			"Making all classes involved final"
		],
		"source": ""
	},
	{
		"id": "java-pp-68",
		"question": "<p>Consider the following classes in your application:</p><div class=\"code\"><p>public class Person {</p><p>&nbsp;&nbsp;private String ssn;</p><p>&nbsp;&nbsp;private String name;</p><p>&nbsp;&nbsp;private int age;</p><p>&nbsp;&nbsp;// getters, setters, methods</p><p>}</p></div><p><div class=\"code\"><p>public class Student extends Person {</p><p>&nbsp;&nbsp;private double gpa;</p><p>&nbsp;&nbsp;private int credits;</p><p>&nbsp;&nbsp;// getters, setters, methods</p><p>}</p></div></p><p>Another programmer comes along and declares the following code:</p><p><div class=\"code\"><p>public class Sophomore extends Student {</p><p>&nbsp;&nbsp;private String[] requiredClasses;</p><p>&nbsp;&nbsp;// getters, setters, methods</p><p>}</p></div></p><p>What can you do to prevent this programmer from using inheritance on your Student class?</p>",
		"correct_answer": "Declare the Student class as final",
		"incorrect_answers": [
			"Declare the Student class as abstract",
			"Declare the Student class as sealed",
			"Declare the Student class as protected"
		],
		"source": ""
	},
	{
		"id": "java-pp-69",
		"question": "You are converting an object-oriented multi-threaded Java application to the functional paradigm using only fully-immutable objects. What is a threading-related advantage of this refactoring?",
		"correct_answer": "You don't need to worry about locking because there is no shared state that can change.",
		"incorrect_answers": [
			"You won't have to worry about performance anymore.",
			"You won't need unit testing anymore.",
			"You will only need one thread."
		],
		"source": ""
	},
	{
		"id": "java-pp-70",
		"question": "<p>You designed the following class to be immutable but it is not. Why not?</p><div class=\"code\"><p>import java.util.Date;</p><p></p><p>public final class SomewhatImmutable {</p><p>&nbsp;&nbsp;private final String id;</p><p>&nbsp;&nbsp;private final Date dateCreated;</p><p>&nbsp;&nbsp;public SomewhatImmutable(String id, Date dateCreated) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;this.dateCreated = dateCreated;</p><p>&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;public String getId() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return id;</p><p>&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;public Date getDateCreated() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return dateCreated;</p><p>&nbsp;&nbsp;}</p><p>}</p></div>",
		"correct_answer": "The Date class is not immutable. You should have used defensive copying in the constructor and the getter to protect the object from changes the original caller made to the Date object and to prevent leaking the mutable Date field with the getter.",
		"incorrect_answers": [
			"The Date class is mutable and objects having a state that contains mutable objects cannot be made immutable without replacing the mutable types of the state with immutable types.",
			"The String class is not immutable. You should have used defensive copying in the constructor and the getter to protect the object from changes the original caller made to the String object and to prevent leaking the mutable String field with the getter.",
			"The class is using a constructor rather than setter methods, which makes it impossible to enforce any immutability constraints when the arguments are passed in."
		],
		"source": ""
	},
	{
		"id": "java-pp-71",
		"question": "<p>What will the following code print out when executed?</p><div class=\"code\"><p>public static void main(String[] args) {</p><p>&nbsp;&nbsp;int aPrimitiveVar = 3;</p><p>&nbsp;&nbsp;System.out.println(aPrimitiveVar);</p><p>&nbsp;&nbsp;updater(aPrimitiveVar);</p><p>&nbsp;&nbsp;System.out.println(aPrimitiveVar);</p><p>}</p><p></p><p>public static void updater(int varToBeUpdated) {</p><p>&nbsp;&nbsp;varToBeUpdated = 20;</p><p>}</p></div>",
		"correct_answer": "<p>3</p><p>3</p>",
		"incorrect_answers": [
			"<p>20</p>",
			"<p>20</p><p>20</p>",
			"<p>3</p><p>20</p>"
		],
		"source": ""
	},
	{
		"id": "java-pp-72",
		"question": "When a child class extends a parent class, how can the child access the instance methods defined at the parent level?",
		"correct_answer": "The child can directly call the instance methods as if they were defined in the child class, provided the parent class method is not private and the method is not overridden in the child class. ",
		"incorrect_answers": [
			"The child must override the parent instance method that it wants to execute and then call it directly from inside the overridden method.",
			"The child can call an instance method of the parent class only if the call is proceeded by a super.",
			"The child can call an instance method of the parent class only if the call is preceeded by a this."
		],
		"source": ""
	}
]